#+TITLE: TODO

- Do Next
  - [ ] Automemoization for everything at least in REPL
    - by string hash
    - for fast interation
    - a :clear / :c command to undo this
  - [-] Remove all partial functions to stop interpreter crashes
    - [-] Take out every:
      - [ ] fromRight' (on e.g. Text.Read)
      - [ ] withPrettyError
      - [X] unsafePerformIO
      - [ ] inexhausive Instances (Semigroup)
      - [ ] OpImpl partiality
      - [ ] Finally take out all compiler warnings
  - [ ] Pattern matching in lambdas; {$[a, [b]] | [b, a]} | [1, [2]] | == [2, 1]
  - [ ] Lexical scope stack so that bindings are evaluated at the right depth and we can ascend upward looking for names
  - [ ] Implement test suite in Crossbow instead; eval from inside Haskell harness
    - add a crossbow test <testfile> command with builtin assertions and messages
    - runTest also written in Crossbow
  - [ ] rename builtins to namespace (but keep HSImpl builtins as builtins)
  - [X] Lib is dynamically loaded with a default value
- Language features
  - [ ] Escaping inside string literals (no way to do \n at the mo)
  - [ ] Tag values with parsing information (e.g. index of character) so that we can give nice error messages on failure
  - [ ] :verbose :v REPL options to switch between truncated / full printing
  - [ ] proper function definition w/ named args
    - should be okay to lean on substitution mechanism if Function stores the names to sub in order
    - workaround: {a <- $0 | b <- $1 | + a b}
  - [ ] emacs mode; syntax, reserved words
  - [ ] Better bootstrapping
    - Write more of stdlib in crossbow
  - [ ] Treat a list full of functions as a function not just for application but also for e.g. folding, mapping
    - can circumvent this by wrapping in {} for now e.g. {[+1,+2]}
  - [ ] Let bindings; getting more and more useful
  - [ ] Binary with no args is repl, with args runs a source file
  - [ ] Move the standard library to a module system
  - [ ] Named function definition
  - [ ] Shortcuts for referring to output of previous line / assignment
  - [ ] Stack trace
  - [ ] range syntax with variable endpoints
    - for now use range function
  - [X] Sets
  - [X] Maps
  - [X] PrettyTruncated class
  - [X] import function that takes a path and runs it in the context
  - [X] DeepEval doesn't know when to stop; we need to find a "fix" in our alias chain
  - [X] What if 'value' can be clauses in parens? that would be our zero-value strict lambda
  - [X] File format with spaces separation is ambiguous
    - Could fix with value parens
  - [X] Move AOC solutions to an external file
    - Kind of working, just needs m
  - [X] Tests for AOC use runFile
  - [X] Reader -> State, allowing builtins to change with execution
  - [X] HSImpl -> wrap with State
  - [X] mapbang for lambdas
    - [X] Num, Semigroup etc classes must error; catch these errors instead as InternalErrors
    - [X] Exhaustive Num
  - [X] Program fragments as lambdas
  - [X] Just added VNull - add Applicaiton rules so that Null is overridden by anythingelse
  - [X] Bind function with aliases - remove need for Valence in the map (move Valence to HSImpl)
  - [X] runFile: in Main, calling on a multiline program parser in Parser which can parse nested Programs in {}
  - [X] REPL / file mode depending on flags
  - [X] REPL also runs in context via e.g. StateT
  - [X] Syntax for mapping - a bang!?
    - Either monadic (args as a list) or variadic (how?)
    - Allow parsing subprograms in parens
  - [X] Spaces in lists are allowed
  - [X] No-arg lambdas assume $0 at the start
  - [X] Un-hardcode 1-lambdas and enable $1+
  - [X] Sliding windows for AOC pt2
  - [X] Remove explicit Valence, infer it from the unbound arguments
  - [X] If/Then/Else
  - [X] Lambdas
  - [X] Start with unnamed lambda args like $0, $1
    - need to terminate when eval'ing Identifier
    - only eval resume after subbing
  - [X] Unify functions and programs; | is just the ap function
    - Do everything in parser including reduction
  - [X] Bools
  - [X] Falsy 0, [] and False
  - [X] Enable builtins written in Crossbow
  - [X] left-partiality e.g 1+ allowed as well as +1
  - [X] partial application for e.g. 1,2,3|+,-,+|4,5,6 = 5,-3,9
  - [X] Text
  - [X] Read from files
  - [X] Functoriality by default (e.g. [1,2,3] + 1 fmaps the addition)
  - [X] explicit casting
  - [X] function values
  - [X] Clause pipes
  - [X] Basic arithmetic
- Interface Features
  - [ ] Compile REPL with Haste for web?
  - [ ] Builtin for reading piped STDIN
  - [ ] Evaluate on keypress
  - [ ] Auto-updating display as you type
  - [ ] With truncation for long strings, lists
  - [ ] AST Tree mode; show forks, monadics as a digraph in ncurses
  - [ ] Terminal colors
  - [ ] Vim-like bindings w/ clause semantics
- Standard Library
  - [X] Functional basics
    - [X] map
    - [X] fold
    - [X] scan
  - [ ] parsing
  - [ ] sorting
  - [ ] lists
  - [ ] sets
  - [ ] search
  - [ ] DS from prims (trees from list-nests, etc)
  - [ ] assoc lists / maps
  - [ ] map utils like countmap
  - [ ] bitwise stuff
- Misc Goals
  - [-] solve 2021 AOC day by day
  - [ ] compile to e.g. LLVM
  - [ ] bootstrapped compiler written in crossbow
